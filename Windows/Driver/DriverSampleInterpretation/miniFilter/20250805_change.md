# change项目
20250805
## README
从代码介绍上看，change项目是一个借助minifilter实现的文件改写监控驱动，其主要任务是为了追踪transacted file，其主要功能包括：
1. 在 post create 回调中，如果以 FILE_WRITE_DATA 或 FILE_APPEND_DATA 属性打开了事务性文件，则将该文件的上下文结构加入到事务上下文中。
2. 在 pre-operation 回调中，如果操作类型属于需要标记为“脏”的操作（例如 IRP_MJ_WRITE），并且目标文件属于事务的一部分，则应更新事务性脏记录，而非非事务性的脏记录。
3. 在内核事务管理器（KTM）的通知回调中，如果事务被提交，则将事务性脏记录中的变更信息传播到非事务性的脏记录中；如果事务被回滚，则不进行传播。
4. 在 TransactionContextCleanup 例程中，正确清理上下文结构。
  
目前我仍然对一些基础概念不甚了解，例如transacted file（事务性文件），FILE_前缀的各类属性，KTM等等，这些新知识都是我将在change项目中解决并学习到的。  

## Transacted File
这一部分是正式开始分析项目之前对事务性文件概念的简单的前置了解；由于参杂了很多个人理解，因此本部分可能不会完全准确，且内容不保证全面。  

事务性NTFS（TxF）：https://learn.microsoft.com/en-us/windows/win32/fileio/transactional-ntfs-portal  
从MSDN文档以及TxF的字面意义上看，TxF是一种在文件系统层面提供的数据库式的事务支持能力，旨在保障故障发生时的数据完整性与一致性，例如，将某次数据读或写视为待提交的原子事务，一旦读写操作发生故障，需要撤回此事务，保证数据不被损坏操作所污染。  

而README部分提及的KTM则是内核提供的事务操作框架：https://learn.microsoft.com/en-us/windows/win32/ktm/kernel-transaction-manager-portal  
而从文档的原话“This allows TxF file operations to be part of a transaction involving other data sources such as SQL Server and Transacted Registry (TxR).”来看，KTM应当是各类事务性操作的统一框架，其不止为TxF提供支持，不过更多的内容此处不进行拓展。

## change.c
### DriverEntry 入口分析
```cpp
    //
    //  Register with FltMgr to tell it our callback routines
    //

    status = FltRegisterFilter( DriverObject,
                                &FilterRegistration,
                                &gFilterInstance );

    if (NT_SUCCESS( status )) {

        //
        //  Start filtering i/o
        //

        status = FltStartFiltering( gFilterInstance );
```
DriverEntry入口处旨在初始化miniFilter驱动的流转例程，通过FltMgr注册并初始化全局结构体。  
File systems and minifilters：https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/_ifsk/  
FltMgr 概念：FltMgr是系统支持的内核模式驱动，暴露了一系列用于文件系统过滤器驱动（File system filter driver）的接口。 https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts  
FltRegisterFilter 用于注册minifilter驱动，FilterRegistration是指向 [FLT_REGISTRATION](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_registration) 结构体的filter参数指针，gFilterInstance是返回的filter实例指针，参数指针的具体配置代码如下：
```cpp
//
//  This defines what we want to filter with FltMgr
//

CONST FLT_REGISTRATION FilterRegistration = {

    sizeof( FLT_REGISTRATION ),         //  Size
    FLT_REGISTRATION_VERSION,           //  Version
    0,                                  //  Flags
    ContextRegistration,                //  Context
    ...
};
```
FLT_REGISTRATION是一个用于FltRegisterFilter函数的注册参数结构，参数结构包含大量FltMgr上下文，回调函数指针成员。从SDK头文件fltKernel.h中可以找到对应结构体`_FLT_REGISTRATION`，观察其结构可得知该结构用以向FltMgr指定状态流转过程中的回调接口，例如结构中的`PFLT_FILTER_UNLOAD_CALLBACK`用以指定filter的卸载接口。  
```cpp
        if (!NT_SUCCESS( status )) {

            FltUnregisterFilter( gFilterInstance );
        }
```
当注册失败时，代码会在分支内调用FltUnregisterFilter以卸载FltMgr指针。DriverEntry至此没有额外内容了，因此下一步应该是去分析FltMgr流转过程中的各项回调，并分析被触发回调中的处理动作。

### FilterRegistration 注册参数解析
```cpp
CONST FLT_REGISTRATION FilterRegistration = {

    sizeof( FLT_REGISTRATION ),         //  Size
    FLT_REGISTRATION_VERSION,           //  Version
    0,                                  //  Flags

    ContextRegistration,                //  Context
    Callbacks,                          //  Operation callbacks

    CgUnload,                           //  MiniFilterUnload

    CgInstanceSetup,                    //  InstanceSetup
    CgInstanceQueryTeardown,            //  InstanceQueryTeardown
    CgInstanceTeardownStart,            //  InstanceTeardownStart
    CgInstanceTeardownComplete,         //  InstanceTeardownComplete

    NULL,                               //  GenerateFileName
    NULL,                               //  GenerateDestinationFileName
    NULL,                               //  NormalizeNameComponent
    CgKtmNotificationCallback           //  KTM notification callback

};
```
[FLT_REGISTRATION structure (fltkernel.h)](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_registration)  
* Flag  
    `Flag`用于指定filter的各类行为，例如`#define FLTFL_REGISTRATION_DO_NOT_SUPPORT_SERVICE_STOP  0x00000001`规定filter不支持服务停止回调，其余定义均可在`fltKernel.h`内找到，不再赘述。此处值为0说明不指定任何额外行为。

* Context  
    上下文对象，不分析。

* Operation callbacks  
    变长`FLT_OPERATION_REGISTRATION`结构数组，用以指定一系列类似“钩子函数”的回调，可以在每次I/O相关操作执行前后挂钩，并执行开发者指定的回调函数。数组结构如下所示：  
    ```cpp
    CONST FLT_OPERATION_REGISTRATION Callbacks[] = {
        { IRP_MJ_CREATE,
          0,
          CgPreCreate,
          CgPostCreate },
          ...
    ```
    [FLT_OPERATION_REGISTRATION](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_operation_registration)  
    根据MSDN对此结构的描述，结构首个UCHAR位（MajorFunction）用于指定特定的I/O操作并进行挂钩，并且该UCHAR位与IRP Code呈映射关系，该例中，结构指定了 IRP_MJ_CREATE 操作并对该IRP进行挂钩，当此IRP被触发时，Filter将根据设定执行操作前（PFLT_PRE_OPERATION_CALLBACK）以及操作后（PFLT_POST_OPERATION_CALLBACK）回调。IRP的触发时机，以及触发函数通常不固定，例如IRP_MJ_CREATE通常在文件创建时触发，但文件创建操作可以被多个接口执行。  
    可挂钩的操作列表可见此文档：  
    https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_parameters  
    同时，每种I/O操作均拥有对应的描述文档，通用的IRP Code描述文档如下：  
    https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-major-function-codes  
    IRP被触发时，通过FltMgr注册的回调通常可以访问系统提供的IRP附带参数，参数以`FLT_PARAMETERS`联合体形式存储，通常可通过回调函数指定的`PFLT_CALLBACK_DATA`结构参数访问，访问路径为`PFLT_CALLBACK_DATA -> Iopb -> Parameters`。根据文档描述，联合体内可包含多个不同的结构，每个结构均对应一个IRP消息及其参数数据，例如`_FLT_PARAMETERS.Create`结构对应IRP_MJ_CREATE消息，假定此时有文件被创建，该IRP会被触发，FltMgr 随后通过例程流转将必要数据传递至挂钩的回调内，驱动因此可以审计或挂钩文件操作。FLT_PARAMETERS联合体样例如下：
    ```cpp
    typedef union _FLT_PARAMETERS {
          struct {
            PIO_SECURITY_CONTEXT     SecurityContext;
            ULONG                    Options;
            USHORT POINTER_ALIGNMENT FileAttributes;
            USHORT                   ShareAccess;
            ULONG POINTER_ALIGNMENT  EaLength;
            PVOID                    EaBuffer;
            LARGE_INTEGER            AllocationSize;
          } Create;
    ```
    FLT_PARAMETERS内的所有结构均有对应文档描述携带的参数内容，以及参数含义。  
    总而言之，如上是`FLT_OPERATION_REGISTRATION`的前置知识，此项目的Callbacks中分别挂钩并指定如下回调：
    - IRP_MJ_CREATE
          - CgPreCreate
          - CgPostCreate
    - IRP_MJ_CLOSE
          - CgPreClose
    - IRP_MJ_WRITE
          - CgPreOperationCallback
    - IRP_MJ_SET_INFORMATION
          - CgPreOperationCallback
    - IRP_MJ_FILE_SYSTEM_CONTROL
          - CgPreFsControl  
    可见除了对常规的文件读写操作挂钩，项目还对修改文件元数据，以及FSCTL请求进行了挂钩。
  
* MiniFilterUnload  
    为Filter指定一个卸载回调，需要注意的是，若不指定则Filter永远不会被卸载。源码内指定了CgUnload为卸载回调。  

* InstanceSetup  
    为Filter指定一个 InstanceSetupCallback 例程，暂不清楚该例程有何作用。源码内指定了 CgInstanceSetup，但其函数体没有进行任何特殊处理。  

* InstanceQueryTeardown/InstanceTeardownStart/InstanceTeardownComplete  
    同上，源码内指定的回调均无特殊逻辑，暂不清楚其作用。  
  
* TransactionNotificationCallback  
    同样是FltMgr的其中一种例程回调，官方文档没有详细说明，但SDK内提及此例程可以接收到KTM发送的事务通知。作用同样不明。  

### IRP/IO操作挂钩细节
源码内`FLT_OPERATION_REGISTRATION`结构数组指定的IRP操作挂钩应该是项目最重要的主体功能
