# change项目
20250805
## README
从代码介绍上看，change项目是一个借助minifilter实现的文件改写监控驱动，其主要任务是为了追踪transacted file，其主要功能包括：
1. 在 post create 回调中，如果以 FILE_WRITE_DATA 或 FILE_APPEND_DATA 属性打开了事务性文件，则将该文件的上下文结构加入到事务上下文中。
2. 在 pre-operation 回调中，如果操作类型属于需要标记为“脏”的操作（例如 IRP_MJ_WRITE），并且目标文件属于事务的一部分，则应更新事务性脏记录，而非非事务性的脏记录。
3. 在内核事务管理器（KTM）的通知回调中，如果事务被提交，则将事务性脏记录中的变更信息传播到非事务性的脏记录中；如果事务被回滚，则不进行传播。
4. 在 TransactionContextCleanup 例程中，正确清理上下文结构。
  
目前我仍然对一些基础概念不甚了解，例如transacted file（事务性文件），FILE_前缀的各类属性，KTM等等，这些新知识都是我将在change项目中解决并学习到的。  

## Transacted File
这一部分是正式开始分析项目之前对事务性文件概念的简单的前置了解；由于参杂了很多个人理解，因此本部分可能不会完全准确，且内容不保证全面。  

事务性NTFS（TxF）：https://learn.microsoft.com/en-us/windows/win32/fileio/transactional-ntfs-portal  
从MSDN文档以及TxF的字面意义上看，TxF是一种在文件系统层面提供的数据库式的事务支持能力，旨在保障故障发生时的数据完整性与一致性，例如，将某次数据读或写视为待提交的原子事务，一旦读写操作发生故障，需要撤回此事务，保证数据不被损坏操作所污染。  

而README部分提及的KTM则是内核提供的事务操作框架：https://learn.microsoft.com/en-us/windows/win32/ktm/kernel-transaction-manager-portal  
而从文档的原话“This allows TxF file operations to be part of a transaction involving other data sources such as SQL Server and Transacted Registry (TxR).”来看，KTM应当是各类事务性操作的统一框架，其不止为TxF提供支持，不过更多的内容此处不进行拓展。

## change.c
### DriverEntry 入口分析
```cpp
    //
    //  Register with FltMgr to tell it our callback routines
    //

    status = FltRegisterFilter( DriverObject,
                                &FilterRegistration,
                                &gFilterInstance );

    if (NT_SUCCESS( status )) {

        //
        //  Start filtering i/o
        //

        status = FltStartFiltering( gFilterInstance );
```
DriverEntry入口处旨在初始化miniFilter驱动的流转例程，通过FltMgr注册并初始化全局结构体。  
File systems and minifilters：https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/_ifsk/  
FltMgr 概念：FltMgr是系统支持的内核模式驱动，暴露了一系列用于文件系统过滤器驱动（File system filter driver）的接口。 https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts  
FltRegisterFilter 用于注册minifilter驱动，FilterRegistration是指向 [FLT_REGISTRATION](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_registration) 结构体的filter参数指针，gFilterInstance是返回的filter实例指针，参数指针的具体配置代码如下：
```cpp
//
//  This defines what we want to filter with FltMgr
//

CONST FLT_REGISTRATION FilterRegistration = {

    sizeof( FLT_REGISTRATION ),         //  Size
    FLT_REGISTRATION_VERSION,           //  Version
    0,                                  //  Flags
    ContextRegistration,                //  Context
    ...
};
```
FLT_REGISTRATION是一个用于FltRegisterFilter函数的注册参数结构，参数结构包含大量FltMgr上下文，回调函数指针成员。从SDK头文件fltKernel.h中可以找到对应结构体`_FLT_REGISTRATION`，观察其结构可得知该结构用以向FltMgr指定状态流转过程中的回调接口，例如结构中的`PFLT_FILTER_UNLOAD_CALLBACK`用以指定filter的卸载接口。  
```cpp
        if (!NT_SUCCESS( status )) {

            FltUnregisterFilter( gFilterInstance );
        }
```
当注册失败时，代码会在分支内调用FltUnregisterFilter以卸载FltMgr指针。DriverEntry至此没有额外内容了，因此下一步应该是去分析FltMgr流转过程中的各项回调，并分析被触发回调中的处理动作。

### FilterRegistration 注册参数解析
```cpp
CONST FLT_REGISTRATION FilterRegistration = {

    sizeof( FLT_REGISTRATION ),         //  Size
    FLT_REGISTRATION_VERSION,           //  Version
    0,                                  //  Flags

    ContextRegistration,                //  Context
    Callbacks,                          //  Operation callbacks

    CgUnload,                           //  MiniFilterUnload

    CgInstanceSetup,                    //  InstanceSetup
    CgInstanceQueryTeardown,            //  InstanceQueryTeardown
    CgInstanceTeardownStart,            //  InstanceTeardownStart
    CgInstanceTeardownComplete,         //  InstanceTeardownComplete

    NULL,                               //  GenerateFileName
    NULL,                               //  GenerateDestinationFileName
    NULL,                               //  NormalizeNameComponent
    CgKtmNotificationCallback           //  KTM notification callback

};
```
[FLT_REGISTRATION structure (fltkernel.h)](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_registration)  
* Flag  
    `Flag`用于指定filter的各类行为，例如`#define FLTFL_REGISTRATION_DO_NOT_SUPPORT_SERVICE_STOP  0x00000001`规定filter不支持服务停止回调，其余定义均可在`fltKernel.h`内找到，不再赘述。此处值为0说明不指定任何额外行为。

* Context  
    上下文对象，不分析。

* Operation callbacks  
    变长`FLT_OPERATION_REGISTRATION`结构数组，用以指定一系列类似“钩子函数”的回调，可以在每次I/O相关操作执行前后挂钩，并执行开发者指定的回调函数。数组结构如下所示：  
    ```cpp
    CONST FLT_OPERATION_REGISTRATION Callbacks[] = {
        { IRP_MJ_CREATE,
          0,
          CgPreCreate,
          CgPostCreate },
          ...
    ```
    [FLT_OPERATION_REGISTRATION](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_operation_registration)  
    根据MSDN对此结构的描述，结构首个UCHAR位（MajorFunction）用于指定特定的I/O操作并进行挂钩，并且该UCHAR位与IRP Code呈映射关系，该例中，结构指定了 IRP_MJ_CREATE 操作并对该IRP进行挂钩，当此IRP被触发时，Filter将根据设定执行操作前（PFLT_PRE_OPERATION_CALLBACK）以及操作后（PFLT_POST_OPERATION_CALLBACK）回调。IRP的触发时机，以及触发函数通常不固定，例如IRP_MJ_CREATE通常在文件创建时触发，但文件创建操作可以被多个接口执行。  
    可挂钩的操作列表可见此文档：  
    https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_parameters  
    同时，每种I/O操作均拥有对应的描述文档，通用的IRP Code描述文档如下：  
    https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-major-function-codes  
    IRP被触发时，通过FltMgr注册的回调通常可以访问系统提供的IRP附带参数，参数以`FLT_PARAMETERS`联合体形式存储，通常可通过回调函数指定的`PFLT_CALLBACK_DATA`结构参数访问，访问路径为`PFLT_CALLBACK_DATA -> Iopb -> Parameters`。根据文档描述，联合体内可包含多个不同的结构，每个结构均对应一个IRP消息及其参数数据，例如`_FLT_PARAMETERS.Create`结构对应IRP_MJ_CREATE消息，假定此时有文件被创建，该IRP会被触发，FltMgr 随后通过例程流转将必要数据传递至挂钩的回调内，驱动因此可以审计或挂钩文件操作。FLT_PARAMETERS联合体样例如下：
    ```cpp
    typedef union _FLT_PARAMETERS {
          struct {
            PIO_SECURITY_CONTEXT     SecurityContext;
            ULONG                    Options;
            USHORT POINTER_ALIGNMENT FileAttributes;
            USHORT                   ShareAccess;
            ULONG POINTER_ALIGNMENT  EaLength;
            PVOID                    EaBuffer;
            LARGE_INTEGER            AllocationSize;
          } Create;
    ```
    FLT_PARAMETERS内的所有结构均有对应文档描述携带的参数内容，以及参数含义。  
    总而言之，如上是`FLT_OPERATION_REGISTRATION`的前置知识，此项目的Callbacks中分别挂钩并指定如下回调：
    - IRP_MJ_CREATE
          - CgPreCreate
          - CgPostCreate
    - IRP_MJ_CLOSE
          - CgPreClose
    - IRP_MJ_WRITE
          - CgPreOperationCallback
    - IRP_MJ_SET_INFORMATION
          - CgPreOperationCallback
    - IRP_MJ_FILE_SYSTEM_CONTROL
          - CgPreFsControl  
    可见除了对常规的文件读写操作挂钩，项目还对修改文件元数据，以及FSCTL请求进行了挂钩。
  
* MiniFilterUnload  
    为Filter指定一个卸载回调，需要注意的是，若不指定则Filter永远不会被卸载。源码内指定了CgUnload为卸载回调。  

* InstanceSetup  
    为Filter指定一个 InstanceSetupCallback 例程，暂不清楚该例程有何作用。源码内指定了 CgInstanceSetup，但其函数体没有进行任何特殊处理。  

* InstanceQueryTeardown/InstanceTeardownStart/InstanceTeardownComplete  
    同上，源码内指定的回调均无特殊逻辑，暂不清楚其作用。  
  
* TransactionNotificationCallback  
    同样是FltMgr的其中一种例程回调，官方文档没有详细说明，但SDK内提及此例程可以接收到KTM发送的事务通知。作用同样不明。  

### IRP/IO操作挂钩细节
源码内`FLT_OPERATION_REGISTRATION`结构数组指定的IRP操作挂钩应该是项目最重要的主体功能，它直接反应了change项目承诺的文件监控功能更具体的实现细节，因此这自然是接下来要分析的目标。  

* **IRP_MJ_CREATE挂钩**  
    `CgPreCreate`是空壳函数，代表IRP触发前不进行操作，直接分析`CgPostCreate`。  
    ```cpp
        NTSTATUS status = Data->IoStatus.Status;
        PCG_FILE_CONTEXT fileContext = NULL;

        if (!NT_SUCCESS( status ) || 
            (status == STATUS_REPARSE)) {
            
            //
            //  File creation may fail.
            //

            CG_DBG_PRINT( CGDBG_TRACE_ROUTINES,
                      ("[CG] CgPostCreate: file creation failed\n") );

            return FLT_POSTOP_FINISHED_PROCESSING;
        }
    ```
    程序首先通过`PFLT_CALLBACK_DATA`结构访问`IO_STATUS_BLOCK`以获取当前IO操作的最终状态，随后对状态进行判断，若状态为非STATUS_SUCCESS或为STATUS_REPARSE时，返回FLT_POSTOP_FINISHED_PROCESSING，该状态代表例程回调已完成，并将控制流交还给FltMgr。  

    其中，代码注释提及`STATUS_REPARSE`可能是一个文件创建失败的状态，同时，官方文档在对函数[`FltCancelFileOpen`](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcancelfileopen)（文档解释其用于在IO操作失败并返回一个NTSTATUS值后关闭文件）的描述中也提及，STATUS_REPARSE代表文件未能成功打开的状态（尽管它是一个有效且成功的NTSTATUS值）。而在SDK代码中，`ntstatus.h`对该状态的原句注释描述是`A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link`，这或许也间接暗示了STATUS_REPARSE状态的产生是由于文件名的某种特性导致文件创建流程未被完成，种种信息都指向一个结论，虽然它不是一个直接反应文件创建失败的状态，但至少它不能代表文件已被正确创建。  
    ```cpp
    //  Find or create a file context
    //

    status = CgFindOrCreateFileContext( Data, 
                                        &fileContext );

    // ... inside CgFindOrCreateFileContext func

        status = FltGetFileContext( Cbd->Iopb->TargetInstance,
                                Cbd->Iopb->TargetFileObject,
                                &fileContext );

        if (status == STATUS_NOT_FOUND) {

        status = CgGetFileId( Cbd->Iopb->TargetInstance,
                      Cbd->Iopb->TargetFileObject,
                      &fileID );

            // ... inside CgGetFileId func
                status = FltGetFileSystemType( Instance, &type );

                if (type == FLT_FSTYPE_REFS) {
                FILE_ID_INFORMATION fileIdInformation;
                status = FltQueryInformationFile( Instance,
                                                  FileObject,
                                                  &fileIdInformation,
                                                  sizeof(FILE_ID_INFORMATION),
                                                  FileIdInformation,
                                                  NULL );
                    if (NT_SUCCESS( status )) {

                        RtlCopyMemory(&FileId->FileId128, &fileIdInformation.FileId, sizeof(FileId->FileId128) );
                    }
                }


        status = CgCreateFileContext( &fileContext );

            // ... inside CgCreateFileContext func

                status = FltAllocateContext( gFilterInstance,
                                 FLT_FILE_CONTEXT,
                                 CG_FILE_CONTEXT_SIZE,
                                 PagedPool,
                                 &fileContext );

        RtlCopyMemory( &fileContext->FileID, &fileID, sizeof(fileContext->FileID) );

        status = FltSetFileContext( Cbd->Iopb->TargetInstance,
                            Cbd->Iopb->TargetFileObject,
                            FLT_SET_CONTEXT_KEEP_IF_EXISTS,
                            fileContext,
                            &oldFileContext );
    ```
    在驱动确认IO操作无误后，程序进入`CgFindOrCreateFileContext`函数，并通过`FltGetFileContext`接口传入IRP_MJ_CREATE所携带Iopb参数中的被操作文件对象，换出文件上下文指针`fileContext`。该文件上下文包含多种类型，例如Stream，Stream的句柄，文件本身，Transactions这些类型，依靠不同类型的上下文可以做到许多不同的操作，这里可见MSDN提供的文档[Managing minifilter contexts](https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/managing-contexts-in-a-minifilter-driver)。  

    如果成功拿到文件上下文，函数会立刻返回，但如果返回状态为STATUS_NOT_FOUND，则程序会尝试获取一个新的文件上下文。  
    在STATUS_NOT_FOUND分支内，函数`CgGetFileId`被调用以通过Iopb参数与FltQueryInformationFile接口拿到文件信息，最终根据指定的文件信息类别（FILE_INFORMATION_CLASS枚举）获得了文件唯一ID，随后通过宏函数RtlCopyMemory将结果转发回上一层函数指定的fileId指针内，该宏函数实际上就是memcpy的实现，Rtl代表NT Runtime Library，至于其它调用到的Flt接口，这里就不再咬文嚼字地介绍了。  

    接着，程序通过FltAllocateContext接口在内核池（内核模式的动态内存池，相当于用户空间的堆）分配一个FLT_FILE_CONTEXT类型的结构体，并调用RtlCopyMemory向其中填充刚刚获取到的fileId。最终，程序通过FltSetFileContext接口将新分配的文件上下文绑定到目标文件对象上，同时指定FLT_SET_CONTEXT_KEEP_IF_EXISTS标记，确保在文件已经拥有上下文的情况下延用旧的上下文。

    在执行完这一切后，该函数返回，总而言之，此函数所做的就是在尝试获取当前IO操作的目标文件上下文。本函数让我们对Flt的通用接口有了一个初步的认知与了解。

